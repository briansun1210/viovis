<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>map</title>
	<link rel="shortcut icon" href="#">
	<script type="text/javascript" src="https://d3js.org/d3.v6.min.js"></script>
	<script type="text/javascript" src="https://d3js.org/topojson.v3.min.js"></script>
	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet"> 
	<link rel="stylesheet" href="../css/US_map.css" />
	<style type="text/css">
	</style>
</head>

<body>
	<script type="text/javascript">
		var proj_state = d3.geoAlbers().scale([750]);
		//var path_state = d3.geoPath().projection(proj_state);

		var spider_div = d3.select("body")
							.append("div")
							.attr("class", "tooltip")
							.style("opacity", 0);
							
		spider_div.append("h1");
		var spider_padding = 25;
		var spider_graph_size = 300;
		
		var bar_svg = spider_div.append("svg")
						.attr("width", 300)
						.attr("height", 20);
						
		var spider_svg = spider_div.append("svg")
						.attr("width", spider_graph_size)
						.attr("height", spider_graph_size);
						
		var svg = d3.select("body")
					.append("svg")
					.attr("width", 1000)
					.attr("height", 500);
					
		d3.json("https://d3js.org/us-10m.v1.json")
			.then(function(json) {
				d3.csv("../data/killingsbystate.csv")
					.then(function(csv) {
						var totals = Array.from(csv, x => ({ total: parseInt(x["# People Killed"]),
															name: x["State"],
															abbr: x["State Abbreviation"],
															black: parseInt(x["# Black people killed"])/parseFloat(x["# People Killed"]),
															hispanic: parseInt(x["# Hispanic people killed"])/parseFloat(x["# People Killed"]),
															native: parseInt(x["# Native American people killed"])/parseFloat(x["# People Killed"]),
															asian: parseInt(x["# Asian people killed"])/parseFloat(x["# People Killed"]),
															pacific: parseInt(x["# Pacific Islanders killed"])/parseFloat(x["# People Killed"]),
															white: parseInt(x["# White people killed"])/parseFloat(x["# People Killed"]),
															unknown: parseInt(x["# Unknown Race people killed"])/parseFloat(x["# People Killed"])
															}));
						var stateScale = d3.scalePow()
											 .exponent(0.4)
											 .domain([0, d3.max(totals, function(d) { return d.total; })])
											 .range(["#ffffff", "#0a4a7d"]);
						var stack = d3.stack()
										.keys(["black", "hispanic", "native", "asian", "pacific", "white", "unknown"])
										.order(d3.stackOrderDescending);
						var stacked_totals = stack(totals);
						
						var barXScale = d3.scaleLinear()
											.domain([0, 1])
											.range([0, 300])
											
						var colors = d3.scaleOrdinal()
										.domain(["black", "hispanic", "native", "asian", "pacific", "white", "unknown"])
										.range(["#006ba4", "#595959", "#ffbc79", "#5f9ed1", "#a2c8ec", "#ff800e", "#ababab"]);
										
						//var stackColumn = (stacked, n) => stacked.map(x => [[x[n][0], x[n][1]]]);
						//console.log(stackColumn(stacked_totals, 0));
						var bar_group = bar_svg.selectAll("g")
										.data(stack([totals[9]]))
										.enter()
										.append("g")
										.style("fill", function(d, i) {
											return colors(i);
										});
						var bar_stack = bar_group.selectAll("rect")
											.data(function(d) { return d; })
											.enter()
											.append("rect")
											.attr("x", function(d) {
												return Math.ceil(barXScale(d[0]));
											})
											.attr("y", 0)
											.attr("height", 20)
											.attr("width", function(d) {
												return Math.ceil(barXScale(d[1]) - barXScale(d[0]));
											});
													
										
						//var ids = Array.from(topojson.feature(json, json.objects.states).features, x => x["id"]);
						var features = topojson.feature(json, json.objects.states).features;
						features.sort((a, b) => (parseInt(a["id"]) < parseInt(b["id"])) ? -1 : 1);
						d3.csv("../data/policekillings.csv")
							.then(function(csv_pk){
								var instances = Array.from(csv_pk, x => ({ race: x["Victim's race"],
																		state: x["State"],
																		armed: x["Armed/Unarmed Status"]
																	 }));
								var state_abbr = Array.from(csv, x => x["State Abbreviation"]);
								var states_spider_data = [];
								var armed_stati = ["Allegedly Armed", "Unarmed/Did Not Have Actual Weapon", "Vehicle", "Unclear"];
								var races = ["Black", "Hispanic", "Native American", "Asian", "Pacific Islander", "White", "Unknown race"];
								for (state in state_abbr) {
									state_race_bd = [];
									for (race in races) {
										var status_per_race = [];
										for (status in armed_stati) {
											var filtered = instances.filter(function(d, i) { return (d.armed === armed_stati[status]) && (d.race === races[race]) && (d.state === state_abbr[state]) });
											status_per_race.push(filtered.length);
										}
										var total = status_per_race.reduce(function(a, b) {return a + b;});
										if (total > 0) {
											status_per_race = status_per_race.map(x => parseFloat(x) / total); // normalization
										}
										state_race_bd.push(status_per_race);
									}
									//states_spider_data.push(({ state_ab: state_abbr[state],
									//						  black: state_race_bd[0],
									//						  hispanic: state_race_bd[1],
									//						  native: state_race_bd[2],
									//						  asian: state_race_bd[3],
									//						  pacific: state_race_bd[4],
									//						  white: state_race_bd[5],
									//						  unknown: state_race_bd[6]}));
									states_spider_data.push(({ state_ab: state_abbr[state], race_data: state_race_bd }));
								}
								
								console.log(states_spider_data);
								
								var reverse_spider_scale = d3.scaleLinear()
													.domain([0, 1])
													.range([0, -(150-spider_padding)]);
								var spider_scale = d3.scaleLinear()
													.domain([0, 1])
													.range([0, 150-spider_padding]);
													
								var vis_scale = d3.scaleLinear()
													.domain([0, 1])
													.range([0, 150-spider_padding]);
								var vis_scale_reverse = d3.scaleLinear()
													.domain([1, 0])
													.range([-(150-spider_padding), 0]);
													
								
								var percent = d3.format(".0%");
								var yAxis = d3.axisRight(vis_scale)
												.tickFormat(percent)
												.ticks(3);
								var yAxis_rev = d3.axisRight(vis_scale_reverse)
												.tickFormat(percent)
												.tickValues([0.5, 1]);
								var xAxis = d3.axisBottom(vis_scale)
												.tickFormat(percent)
												.ticks(3);
								
													
								//var vert_ax = spider_svg.append("g")
								//						.attr("class", "axis")
								//						.attr("transform", "translate(150, 150)")
								//						.call(yAxis);
								var vert_ax_rev = spider_svg.append("g")
														.attr("class", "axis")
														.attr("transform", "translate(150, 150)")
														.call(yAxis_rev);
								var x_right_ax = spider_svg.append("line")
														.style("stroke", "black")
														.style("stroke-width", 1)
														.attr("x1", 150)
														.attr("y1", 150)
														.attr("x2", 300-spider_padding)
														.attr("y2", 150);
								var x_left_ax = spider_svg.append("line")
														.style("stroke", "black")
														.style("stroke-width", 1)
														.attr("x1", 150)
														.attr("y1", 150)
														.attr("x2", spider_padding)
														.attr("y2", 150);
								var y_bottom_ax = spider_svg.append("line")
														.style("stroke", "black")
														.style("stroke-width", 1)
														.attr("x1", 150)
														.attr("y1", 150)
														.attr("x2", 150)
														.attr("y2", 300-spider_padding);
														
								var armed_txt = spider_svg.append("text")
														.attr("x", 150-38.75)
														.attr("y", spider_padding/2.0)
														.attr("class", "spider-label")
														.text("Allegedly Armed");
														
								var unclear_txt = spider_svg.append("text")
														.attr("x", 300-(spider_padding/2.0))
														.attr("y", 150-20)
														.attr("class", "spider-label")
														.attr("id", "right-vert")
														.text("Unclear");
														
								var vehicle_txt = spider_svg.append("text")
														.attr("x", -(spider_padding/2.0))
														.attr("y", -(150+17.5))
														.attr("class", "spider-label")
														.attr("id", "left-vert")
														.text("Vehicle")
														.attr("transform", "rotate(-180)");
														
								var unarmed_txt = spider_svg.append("text")
														.attr("x", 150-22.5)
														.attr("y", 300-(spider_padding/2.0))
														.attr("class", "spider-label")
														.text("Unarmed");
														
								var race_polygons = spider_svg.selectAll("polygon")
														.data(states_spider_data[0].race_data)
														.enter()
														.append("polygon")
														.attr("class", "spider-polygon")
														.style("stroke-width", 1)
														.style("stroke", function(d, i) {
															return colors(i);
														})
														//.data(function(d) { return [d]; })
														.attr("points", function(d) {
															// d is per race, so the array of values
															points_str = 150+","+(150+reverse_spider_scale(d[0]))+" "+
																		 (150+reverse_spider_scale(d[2]))+","+150+" "+
																		 150+","+(150+spider_scale(d[1]))+" "+
																		 (150+spider_scale(d[3]))+","+150;
															return points_str;
														})
														.attr("fill", function(d, i) {
															return colors(i);
														})
														.attr("fill-opacity", 0.25);
														
								var race_group = spider_svg.selectAll("g.race-group")
														.data(states_spider_data[0].race_data)
														.enter()
														.append("g")
														.attr("class", "race-group")
														.style("fill", function(d, i) {
															return colors(i);
														});
														
								var race_points = race_group.selectAll("circle")
														.data(function(d) { return d; })
														.enter()
														.append("circle")
														.attr("r", 2.5)
														.attr("cx", function(d, i) {
															if (i == 0 || i == 1) {
																return 150;
															}
															else if (i == 2) { return 150+reverse_spider_scale(d); }
															else if (i == 3) { return 150+spider_scale(d); }
														})
														.attr ("cy", function(d, i) {
															if (i == 2 || i == 3) {
																return 150;
															}
															else if (i == 0) { return 150+reverse_spider_scale(d); }
															else if (i == 1) { return 150+spider_scale(d); }
														});
								
							
								svg.selectAll("path")
									.data(features)
									.enter()
									.append("path")
									.attr("d", d3.geoPath(d3.geoTransform({
										point: function(x, y) {
											this.stream.point(x * 0.75 + (svg.attr("width")*0.125), y * 0.75);
										}
									})))
									.style("stroke", "#ffffff")
									.style("stroke-width", "1")
									.data(totals)
									.style("fill", function(d) {
										return stateScale(d.total);
									})
									.on("mouseover", function(event, d) {
										d3.select(event.currentTarget).style("fill", "#222222");
										spider_div.style("opacity", 1);
									})
									.on("mousemove", function(event, d) {
										var mouse_pos = d3.pointer(event, svg);
										spider_div.style("left", mouse_pos[0]+"px").style("top", mouse_pos[1]+"px");
										spider_div.selectAll("h1").text(d.name.toUpperCase());
										var state_bar = stack([d]);
										bar_group.data(state_bar).enter();
										bar_group.selectAll("rect")
												.data(function(d) { return d; })
												.transition()
												.duration(1)
												.attr("x", function(d) {
													return Math.ceil(barXScale(d[0]));
												})
												.attr("width", function(d) {
													return Math.ceil(barXScale(d[1]) - barXScale(d[0]));
												});
										//console.log(states_spider_data[4].state_ab === d.abbr);
										//console.log(states_spider_data.filter(function(statum, i) { return statum.state_ab === d.abbr; }));
										var new_race_data = states_spider_data.filter(function(data) { return data.state_ab === d.abbr; })[0].race_data;
										race_group.data(new_race_data).enter();
										race_polygons.data(new_race_data).enter()
										spider_svg.selectAll("polygon")
													.transition()
													.duration(1)
													.attr("points", function(d) {
														// d is per race, so the array of values
														points_str = 150+","+(150+reverse_spider_scale(d[0]))+" "+
																	 (150+reverse_spider_scale(d[2]))+","+150+" "+
																	 150+","+(150+spider_scale(d[1]))+" "+
																	 (150+spider_scale(d[3]))+","+150;
														return points_str;
													})
													.attr("fill", function(d, i) {
														return colors(i);
													})
													.attr("fill-opacity", 0.25);
										race_group.selectAll("circle")
												.data(function(d) { return d; })
												.transition()
												.duration(1)
												.attr("cx", function(d, i) {
													if (i == 0 || i == 1) {
														return 150;
													}
													else if (i == 2) { return 150+reverse_spider_scale(d); }
													else if (i == 3) { return 150+spider_scale(d); }
												})
												.attr ("cy", function(d, i) {
													if (i == 2 || i == 3) {
														return 150;
													}
													else if (i == 0) { return 150+reverse_spider_scale(d); }
													else if (i == 1) { return 150+spider_scale(d); }
												});
									})
									.on("mouseout", function(event, d) {
										d3.select(event.currentTarget).style("fill", function(d) {
											return stateScale(d.total);
										})
									})
									.on("mouseleave", function(event, d) {
										spider_div.style("opacity", 0);
									});
						});
					});
			});
		var states = svg.selectAll("path");
	</script>
</body>

</html>