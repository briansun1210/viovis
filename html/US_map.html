<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>map</title>
	<link rel="shortcut icon" href="#">
	<script type="text/javascript" src="https://d3js.org/d3.v6.min.js"></script>
	<script type="text/javascript" src="https://d3js.org/topojson.v3.min.js"></script>
	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet"> 
	<link rel="stylesheet" href="../css/US_map.css" />
	<style type="text/css">
	</style>
</head>

<body>
	<script type="text/javascript">
		var proj_state = d3.geoAlbers().scale([750]);
		//var path_state = d3.geoPath().projection(proj_state);

		var spider_div = d3.select("body")
							.append("div")
							.attr("class", "tooltip")
							.style("opacity", 0);
							
		spider_div.append("h1");
		spider_div.append("h2").text("Breakdown of Police Killings by Race");
		var spider_padding = 25;
		var spider_graph_size = 300;
		
		var bar_svg = spider_div.append("svg")
						.attr("width", 300)
						.attr("height", 20);
						
		var spider_svg = spider_div.append("svg")
						.attr("width", spider_graph_size)
						.attr("height", spider_graph_size);
						
		var svg = d3.select("body")
					.append("svg")
					.attr("width", 1000)
					.attr("height", 500);
					
		d3.json("https://d3js.org/us-10m.v1.json")
			.then(function(json) {
				d3.csv("../data/killingsbystate.csv")
					.then(function(csv) {
						var totals = Array.from(csv, x => ({ total: parseFloat(x["# People Killed"])/parseInt(x["Total Population"].replace(/,/g, "")),
															pop: parseInt(x["Total Population"].replace(/,/g, "")),
															name: x["State"],
															abbr: x["State Abbreviation"],
															black: parseInt(x["# Black people killed"])/parseFloat(x["# People Killed"]),
															hispanic: parseInt(x["# Hispanic people killed"])/parseFloat(x["# People Killed"]),
															native: parseInt(x["# Native American people killed"])/parseFloat(x["# People Killed"]),
															asian: parseInt(x["# Asian people killed"])/parseFloat(x["# People Killed"]),
															pacific: parseInt(x["# Pacific Islanders killed"])/parseFloat(x["# People Killed"]),
															white: parseInt(x["# White people killed"])/parseFloat(x["# People Killed"]),
															unknown: parseInt(x["# Unknown Race people killed"])/parseFloat(x["# People Killed"])
															}));
						var stateScale = d3.scaleLinear()
											 //.exponent(0.4)
											 .domain([0, d3.max(totals, function(d) { return d.total; })])
											 .range(["#ffffff", "#0a4a7d"]);
						var stateScale_numerical = d3.scaleLinear()
											 //.exponent(0.4)
											 .domain(stateScale.domain())
											 .range([0, 300]);
						console.log(d3.max(totals, function(d) { return d.total; }));
						console.log(totals[31]);
									
						var stack = d3.stack()
										.keys(["black", "hispanic", "native", "asian", "pacific", "white", "unknown"])
										.order(d3.stackOrderDescending);
						var stacked_totals = stack(totals);
						
						var barXScale = d3.scaleLinear()
											.domain([0, 1])
											.range([0, 300])
											
						var colors = d3.scaleOrdinal()
										.domain(["black", "hispanic", "native", "asian", "pacific", "white", "unknown"])
										.range(["#006ba4", "#595959", "#ffbc79", "#5f9ed1", "#a2c8ec", "#ff800e", "#ababab"]);
										
						//var stackColumn = (stacked, n) => stacked.map(x => [[x[n][0], x[n][1]]]);
						//console.log(stackColumn(stacked_totals, 0));
						var bar_group = bar_svg.selectAll("g")
										.data(stack([totals[9]]))
										.enter()
										.append("g")
										.style("fill", function(d, i) {
											return colors(i);
										});
						var bar_stack = bar_group.selectAll("rect")
											.data(function(d) { return d; })
											.enter()
											.append("rect")
											.attr("x", function(d) {
												return Math.ceil(barXScale(d[0]));
											})
											.attr("y", 0)
											.attr("height", 20)
											.attr("width", function(d) {
												return Math.ceil(barXScale(d[1]) - barXScale(d[0]));
											});
						
						var loading_txt = svg.append("text")
											.attr("x", 350)
											.attr("y", 250)
											.attr("class", "loading")
											.text("LOADING...");
										
						//var ids = Array.from(topojson.feature(json, json.objects.states).features, x => x["id"]);
						var features = topojson.feature(json, json.objects.states).features;
						features.sort((a, b) => (parseInt(a["id"]) < parseInt(b["id"])) ? -1 : 1);
						d3.csv("../data/policekillings.csv")
							.then(function(csv_pk){
								var instances = Array.from(csv_pk, x => ({ race: x["Victim's race"],
																		state: x["State"],
																		armed: x["Armed/Unarmed Status"]
																	 }));
								var state_abbr = Array.from(csv, x => x["State Abbreviation"]);
								var states_spider_data = [];
								var armed_stati = ["Allegedly Armed", "Unarmed/Did Not Have Actual Weapon", "Vehicle", "Unclear"];
								var races = ["Black", "Hispanic", "Native American", "Asian", "Pacific Islander", "White", "Unknown race"];
								for (state in state_abbr) {
									state_race_bd = [];
									for (race in races) {
										var status_per_race = [];
										for (status in armed_stati) {
											var filtered = instances.filter(function(d, i) { return (d.armed === armed_stati[status]) && (d.race === races[race]) && (d.state === state_abbr[state]) });
											status_per_race.push(filtered.length);
										}
										var total = status_per_race.reduce(function(a, b) {return a + b;});
										if (total > 0) {
											status_per_race = status_per_race.map(x => parseFloat(x) / total); // normalization
										}
										state_race_bd.push(status_per_race);
									}
									//states_spider_data.push(({ state_ab: state_abbr[state],
									//						  black: state_race_bd[0],
									//						  hispanic: state_race_bd[1],
									//						  native: state_race_bd[2],
									//						  asian: state_race_bd[3],
									//						  pacific: state_race_bd[4],
									//						  white: state_race_bd[5],
									//						  unknown: state_race_bd[6]}));
									states_spider_data.push(({ state_ab: state_abbr[state], race_data: state_race_bd }));
								}
																
								var reverse_spider_scale = d3.scaleLinear()
													.domain([0, 1])
													.range([0, -(150-spider_padding)]);
								var spider_scale = d3.scaleLinear()
													.domain([0, 1])
													.range([0, 150-spider_padding]);
													
								var vis_scale = d3.scaleLinear()
													.domain([0, 1])
													.range([0, 150-spider_padding]);
								var vis_scale_reverse = d3.scaleLinear()
													.domain([1, 0])
													.range([-(150-spider_padding), 0]);
													
								
								var percent = d3.format(".0%");
								var yAxis = d3.axisRight(vis_scale)
												.tickFormat(percent)
												.ticks(3);
								var yAxis_rev = d3.axisRight(vis_scale_reverse)
												.tickFormat(percent)
												.tickValues([0.5, 1]);
								var xAxis = d3.axisBottom(vis_scale)
												.tickFormat(percent)
												.ticks(3);
								
													
								//var vert_ax = spider_svg.append("g")
								//						.attr("class", "axis")
								//						.attr("transform", "translate(150, 150)")
								//						.call(yAxis);
								var vert_ax_rev = spider_svg.append("g")
														.attr("class", "axis")
														.attr("transform", "translate(150, 150)")
														.call(yAxis_rev);
								var x_right_ax = spider_svg.append("line")
														.style("stroke", "black")
														.style("stroke-width", 1)
														.style("shape-rendering", "crispEdges")
														.attr("x1", 150)
														.attr("y1", 150)
														.attr("x2", 300-spider_padding)
														.attr("y2", 150);
								var x_left_ax = spider_svg.append("line")
														.style("stroke", "black")
														.style("stroke-width", 1)
														.style("shape-rendering", "crispEdges")
														.attr("x1", 150)
														.attr("y1", 150)
														.attr("x2", spider_padding)
														.attr("y2", 150);
								var y_bottom_ax = spider_svg.append("line")
														.style("stroke", "black")
														.style("stroke-width", 1)
														.style("shape-rendering", "crispEdges")
														.attr("x1", 150)
														.attr("y1", 150)
														.attr("x2", 150)
														.attr("y2", 300-spider_padding);
														
								var armed_txt = spider_svg.append("text")
														.attr("x", 150-38.75)
														.attr("y", spider_padding/2.0)
														.attr("class", "spider-label")
														.text("Allegedly Armed");
														
								var unclear_txt = spider_svg.append("text")
														.attr("x", 300-(spider_padding/2.0))
														.attr("y", 150-20)
														.attr("class", "spider-label")
														.attr("id", "right-vert")
														.text("Unclear");
														
								var vehicle_txt = spider_svg.append("text")
														.attr("x", -(spider_padding/2.0))
														.attr("y", -(150+17.5))
														.attr("class", "spider-label")
														.attr("id", "left-vert")
														.text("Vehicle")
														.attr("transform", "rotate(-180)");
														
								var unarmed_txt = spider_svg.append("text")
														.attr("x", 150-22.5)
														.attr("y", 300-(spider_padding/2.0))
														.attr("class", "spider-label")
														.text("Unarmed");
														
								var race_polygons = spider_svg.selectAll("polygon")
														.data(states_spider_data[0].race_data)
														.enter()
														.append("polygon")
														.attr("class", "spider-polygon")
														.style("stroke-width", 1)
														.style("stroke", function(d, i) {
															return colors(i);
														})
														//.data(function(d) { return [d]; })
														.attr("points", function(d) {
															// d is per race, so the array of values
															points_str = 150+","+(150+reverse_spider_scale(d[0]))+" "+
																		 (150+reverse_spider_scale(d[2]))+","+150+" "+
																		 150+","+(150+spider_scale(d[1]))+" "+
																		 (150+spider_scale(d[3]))+","+150;
															return points_str;
														})
														.attr("fill", function(d, i) {
															return colors(i);
														})
														.attr("fill-opacity", 0.25);
														
								var race_group = spider_svg.selectAll("g.race-group")
														.data(states_spider_data[0].race_data)
														.enter()
														.append("g")
														.attr("class", "race-group")
														.style("fill", function(d, i) {
															return colors(i);
														});
														
								var race_points = race_group.selectAll("circle")
														.data(function(d) { return d; })
														.enter()
														.append("circle")
														.attr("r", 2.5)
														.attr("cx", function(d, i) {
															if (i == 0 || i == 1) {
																return 150;
															}
															else if (i == 2) { return 150+reverse_spider_scale(d); }
															else if (i == 3) { return 150+spider_scale(d); }
														})
														.attr ("cy", function(d, i) {
															if (i == 2 || i == 3) {
																return 150;
															}
															else if (i == 0) { return 150+reverse_spider_scale(d); }
															else if (i == 1) { return 150+spider_scale(d); }
														});
								var spider_legend = spider_div.append("svg")
															.attr("width", 300)
															.attr("height", 70);
								for (race in races) {
									spider_legend.append("rect")
												.attr("width", 12)
												.attr("height", 12)
												.attr("x", 20+(race*86)-(parseInt(race/3)*258)+(parseInt(race/6)*66)-(race%3==1 ? 20 : 0))
												.attr("y", 0+(parseInt(race/3)*20))
												.style("stroke", "black")
												.style("stroke-width", "1")
												.style("shape-rendering", "crispEdges")
												.attr("fill", colors(races[race]));
									spider_legend.append("text")
												.attr("x", 40+(race*86)-(parseInt(race/3)*258)+(parseInt(race/6)*66)-(race%3==1 ? 20 : 0))
												.attr("y", 10+(parseInt(race/3)*20))
												.attr("fill", "black")
												.attr("class", "spider-label")
												.text(races[race]);
								}
							
								svg.selectAll("path")
									.data(features)
									.enter()
									.append("path")
									.attr("d", d3.geoPath(d3.geoTransform({
										point: function(x, y) {
											this.stream.point(x * 0.75 + (svg.attr("width")*0.125), y * 0.75);
										}
									})))
									.style("stroke", "#002760")
									.style("stroke-width", "1")
									.data(totals)
									.style("fill", function(d) {
										return stateScale(d.total);
									})
									.on("mouseover", function(event, d) {
										d3.select(event.currentTarget).style("fill", "#222222").style("stroke", "white").style("stroke-width", 2);
										spider_div.style("opacity", 1);
										this.parentNode.appendChild(this);
									})
									.on("mousemove", function(event, d) {
										var mouse_pos = d3.pointer(event, svg);
										spider_div.style("left", mouse_pos[0]+"px").style("top", mouse_pos[1]+"px");
										spider_div.selectAll("h1").text(d.name.toUpperCase());
										var state_bar = stack([d]);
										bar_group.data(state_bar).enter();
										bar_group.selectAll("rect")
												.data(function(d) { return d; })
												.transition()
												.duration(1)
												.attr("x", function(d) {
													return Math.ceil(barXScale(d[0]));
												})
												.attr("width", function(d) {
													return Math.ceil(barXScale(d[1]) - barXScale(d[0]));
												});
										//console.log(states_spider_data[4].state_ab === d.abbr);
										//console.log(states_spider_data.filter(function(statum, i) { return statum.state_ab === d.abbr; }));
										var new_race_data = states_spider_data.filter(function(data) { return data.state_ab === d.abbr; })[0].race_data;
										race_group.data(new_race_data).enter();
										race_polygons.data(new_race_data).enter()
										spider_svg.selectAll("polygon")
													.transition()
													.duration(1)
													.attr("points", function(d) {
														// d is per race, so the array of values
														points_str = 150+","+(150+reverse_spider_scale(d[0]))+" "+
																	 (150+reverse_spider_scale(d[2]))+","+150+" "+
																	 150+","+(150+spider_scale(d[1]))+" "+
																	 (150+spider_scale(d[3]))+","+150;
														return points_str;
													})
													.attr("fill", function(d, i) {
														return colors(i);
													})
													.attr("fill-opacity", 0.25);
										race_group.selectAll("circle")
												.data(function(d) { return d; })
												.transition()
												.duration(1)
												.attr("cx", function(d, i) {
													if (i == 0 || i == 1) {
														return 150;
													}
													else if (i == 2) { return 150+reverse_spider_scale(d); }
													else if (i == 3) { return 150+spider_scale(d); }
												})
												.attr ("cy", function(d, i) {
													if (i == 2 || i == 3) {
														return 150;
													}
													else if (i == 0) { return 150+reverse_spider_scale(d); }
													else if (i == 1) { return 150+spider_scale(d); }
												});
									})
									.on("mouseout", function(event, d) {
										d3.select(event.currentTarget).style("fill", function(d) {
											return stateScale(d.total);
										}).style("stroke", "#002760").style("stroke-width", 1);
									})
									.on("mouseleave", function(event, d) {
										spider_div.style("opacity", 0);
									});
									
								var grad = svg.append("defs")
											  .append("linearGradient")
											  .attr("id", "grad")
											  .selectAll("stop")
											  .data(stateScale.ticks().map((t, i, n) => ({ offset: `${100*i/n.length}%`, color: stateScale(t) })))
											  .enter()
											  .append("stop")
											  .attr("offset", function(d) {
													return d.offset;
											  })
											  .attr("stop-color", function(d) {
													return d.color;
											  });
									  
								var legend_txt = svg.append("text")
														.attr("x", 15)
														.attr("y", 75)
														.attr("class", "state-legend")
														.attr("dx", "1em")
														.text("Police Killings")
								var legend_txt_2 = svg.append("text")
														.attr("x", 15)
														.attr("y", 75)
														.attr("class", "state-legend")
														.attr("dy", "1.2em")
														.text("as % of Population");
									  
								var state_legend = svg.append("g")
													.attr("transform", "translate(70, 100), rotate(90)")
													.append("rect")
													.attr("width", 300)
													.attr("height", 20)
													.style("fill", "url(#grad)");
								var percent_acc = d3.format(".3%");
								var legend_axis = d3.axisLeft(stateScale_numerical).tickValues([0, 0.00001, 0.00002, 0.00003, 0.00004, 0.00005, 0.00006, 0.00007]).tickFormat(percent_acc);
								var state_legend_axis = svg.append("g").call(legend_axis);
								state_legend_axis.selectAll(".tick text")
											.attr("transform", "translate(50, 100)")
											.attr("color", "white");
								state_legend_axis.selectAll(".tick line")
											.attr("transform", "translate(70, 100)")
											.attr("x2", -26);
								state_legend_axis.selectAll(".domain")
											.attr("transform", "translate(70, 100)");
								});
					});
			});
		var states = svg.selectAll("path");
	</script>
</body>

</html>